package cri

import (
	"context"
	"fmt"
	"strings"

	log "github.com/sirupsen/logrus"
	"github.com/srl-labs/containerlab/clab/exec"
	"github.com/srl-labs/containerlab/runtime"
	"github.com/srl-labs/containerlab/types"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	v1 "k8s.io/cri-api/pkg/apis/runtime/v1"
)

const (
	CRI_RUNTIME_NAME = "CRI"
)

type CRI struct {
	config               runtime.RuntimeConfig
	runtimeServiceClient v1.RuntimeServiceClient
	imageServiceClient   v1.ImageServiceClient
}

// Initializes the Container runtime struct
func (c *CRI) Init(...runtime.RuntimeOption) error {
	conn, err := grpc.Dial("unix:///run/cri-dockerd.sock", grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		return err
	}

	c.runtimeServiceClient = v1.NewRuntimeServiceClient(conn)
	c.imageServiceClient = v1.NewImageServiceClient(conn)
	return nil
}

// Mgmt return management network configuration of a runtime
func (c *CRI) Mgmt() *types.MgmtNet {
	// TODO
	return nil
}

// Adds custom configuration items to the container runtime struct
func (c *CRI) WithConfig(*runtime.RuntimeConfig) {
	// TODO
}

// Set the network management details (generated by the config.go)
func (c *CRI) WithMgmtNet(*types.MgmtNet) {
	// TODO
}

// Instructs the runtime not to delete the mgmt network on destroy
func (c *CRI) WithKeepMgmtNet() {
	// TODO
}

// Create container (bridge) network
func (c *CRI) CreateNet(context.Context) error {
	// TODO
	return nil
}

// Delete container (bridge) network
func (c *CRI) DeleteNet(context.Context) error {
	// TODO
	return nil
}

// Pull container image if not present
func (c *CRI) PullImage(ctx context.Context, image string, pullPolicy types.PullPolicyValue) error {

	// TODO implement PullPolicy
	_, err := c.imageServiceClient.PullImage(ctx, &v1.PullImageRequest{
		Image: &v1.ImageSpec{
			Image: image,
		},
	})

	return err

}

// CreateContainer creates a container, but does not start it
func (c *CRI) CreateContainer(ctx context.Context, nc *types.NodeConfig) (string, error) {

	sbName := nc.ShortName + "-sandbox"

	podSandBoxConfig := &v1.PodSandboxConfig{
		Hostname: sbName,
		Linux: &v1.LinuxPodSandboxConfig{
			Sysctls: nc.Sysctls,
		},
		Metadata: &v1.PodSandboxMetadata{
			Name:      sbName,
			Namespace: "default",
		},
		Labels: nc.Labels,
	}

	resoCreatePodSB, err := c.runtimeServiceClient.RunPodSandbox(ctx, &v1.RunPodSandboxRequest{
		Config: podSandBoxConfig,
	})
	if err != nil {
		return "", err
	}

	createContainerReq := &v1.CreateContainerRequest{
		PodSandboxId:  resoCreatePodSB.PodSandboxId,
		SandboxConfig: podSandBoxConfig,
		Config: &v1.ContainerConfig{
			Image:    &v1.ImageSpec{Image: nc.Image},
			Command:  nc.Exec,
			Labels:   nc.Labels,
			Metadata: &v1.ContainerMetadata{Name: nc.ShortName},
		},
	}

	// mounts
	for _, v := range nc.Binds {
		parts := strings.Split(v, ":")

		hostPath := parts[0]
		containerPath := parts[1]

		mount := &v1.Mount{
			HostPath:      hostPath,
			ContainerPath: containerPath,
		}

		if len(parts) == 3 {
			if parts[2] == "ro" {
				mount.Readonly = true
			}
		}

		createContainerReq.Config.Mounts = append(createContainerReq.Config.Mounts, mount)
	}

	// environment variables
	for k, v := range nc.Env {
		createContainerReq.Config.Envs = append(createContainerReq.Config.Envs, &v1.KeyValue{Key: k, Value: v})
	}

	respCreateCont, err := c.runtimeServiceClient.CreateContainer(ctx, createContainerReq)
	if err != nil {
		return "", err
	}

	return respCreateCont.ContainerId, nil
}

// Start pre-created container by its name. Returns an extra interface that can be used to receive signals
// about the container life-cycle after it was created, e.g. for post-deploy tasks
func (c *CRI) StartContainer(ctx context.Context, cID string, _ *types.NodeConfig) (interface{}, error) {
	_, err := c.runtimeServiceClient.StartContainer(ctx, &v1.StartContainerRequest{
		ContainerId: cID,
	})
	return nil, err
}

// Stop running container by its name
func (c *CRI) StopContainer(ctx context.Context, cID string) error {
	_, err := c.runtimeServiceClient.StopContainer(ctx, &v1.StopContainerRequest{
		ContainerId: cID,
	})
	return err
}

// Pause a container identified by its name
func (c *CRI) PauseContainer(ctx context.Context, cID string) error {
	// NOOP
	return nil
}

// UnPause / resume a container identified by its name
func (c *CRI) UnpauseContainer(context.Context, string) error {
	// NOOP
	return nil
}

// List all containers matching labels
func (c *CRI) ListContainers(ctx context.Context, filter []*types.GenericFilter) ([]runtime.GenericContainer, error) {
	resp, err := c.runtimeServiceClient.ListContainers(ctx, &v1.ListContainersRequest{})
	if err != nil {
		return nil, err
	}

	result := make([]runtime.GenericContainer, 0, len(resp.Containers))

	for _, x := range resp.Containers {
		result = append(result, runtime.GenericContainer{
			Names:  []string{x.Id},
			Labels: x.Labels,
			State:  x.State.String(),
			Image:  x.Image.Image,
		})
	}
	return result, nil
}

// Get a netns path using the pid of a container
func (c *CRI) GetNSPath(ctx context.Context, cID string) (string, error) {
	// TODO
	resp, err := c.runtimeServiceClient.Status(ctx, &v1.StatusRequest{
		Verbose: true,
	})
	if err != nil {
		return "", err
	}

	log.Infof("Infos: %s", strings.Join(StringMap2StringSlice(resp.Info), ", "))

	return strings.Join(StringMap2StringSlice(resp.Info), ", "), nil
}

// Executes cmd on container identified with id and returns stdout, stderr bytes and an error
func (c *CRI) Exec(ctx context.Context, cID string, execCmd *exec.ExecCmd) (*exec.ExecResult, error) {
	// TODO
	return nil, nil
}

// ExecNotWait executes cmd on container identified with id but doesn't wait for output nor attaches stdout/err
func (c *CRI) ExecNotWait(ctx context.Context, cID string, execCmd *exec.ExecCmd) error {
	// TODO
	return nil
}

// Delete container by its name
func (c *CRI) DeleteContainer(context.Context, string) error {
	// TODO
	return nil
}

// Getter for runtime config options
func (c *CRI) Config() runtime.RuntimeConfig {
	return c.config
}

func (c *CRI) GetName() string {
	return CRI_RUNTIME_NAME
}

// GetHostsPath returns fs path to a file which is mounted as /etc/hosts into a given container
func (c *CRI) GetHostsPath(context.Context, string) (string, error) {
	// TODO

	return "", nil
}

// GetContainerStatus retrieves the ContainerStatus of the named container
func (c *CRI) GetContainerStatus(ctx context.Context, cID string) runtime.ContainerStatus {
	s, err := c.runtimeServiceClient.ContainerStatus(
		ctx, &v1.ContainerStatusRequest{
			ContainerId: cID,
			Verbose:     true,
		},
	)
	if err != nil {
		return runtime.NotFound
	}

	fmt.Printf("Info: %v\n", s.GetInfo())

	var result runtime.ContainerStatus = runtime.Stopped

	switch s.Status.State {
	case v1.ContainerState_CONTAINER_RUNNING:
		result = runtime.Running
	case v1.ContainerState_CONTAINER_UNKNOWN:
		result = runtime.NotFound
	}
	return result
}

func StringMap2StringSlice(m map[string]string) []string {
	result := []string{}
	for k, v := range m {
		result = append(result, fmt.Sprintf("%s: %s", k, v))
	}
	return result
}
